from abc import ABC, abstractmethod
from enum import Enum, IntEnum
from dataclasses import dataclass
from typing import Union
from io import BytesIO
from Crypto.PublicKey import RSA
from pyisotools.security import signature

from pyisotools.security.signature import Signature, SignatureRSA2048, SignatureRSA4096
from pyisotools.tools import read_string, read_uint32


ROOT_CERT_SIG = (
    b"\xB3\xAD\xB3\x22\x6B\x3C\x3D\xFF\x1B\x4B\x40\x77\x16\xFF\x4F\x7A",
    b"\xD7\x64\x86\xC8\x95\xAC\x56\x2D\x21\xF1\x06\x01\xD4\xF6\x64\x28",
    b"\x19\x1C\x07\x76\x8F\xDF\x1A\xE2\xCE\x7B\x27\xC9\x0F\xBC\x0A\xD0",
    b"\x31\x25\x78\xEC\x07\x79\xB6\x57\xD4\x37\x24\x13\xA7\xF8\x6F\x0C",
    b"\x14\xC0\xEF\x6E\x09\x41\xED\x2B\x05\xEC\x39\x57\x36\x07\x89\x00",
    b"\x4A\x87\x8D\x2E\x9D\xF8\xC7\xA5\xA9\xF8\xCA\xB3\x11\xB1\x18\x79",
    b"\x57\xBB\xF8\x98\xE2\xA2\x54\x02\xCF\x54\x39\xCF\x2B\xBF\xA0\xE1",
    b"\xF8\x5C\x06\x6E\x83\x9A\xE0\x94\xCA\x47\xE0\x15\x58\xF5\x6E\x6F",
    b"\x34\xE9\x2A\xA2\xDC\x38\x93\x7E\x37\xCD\x8C\x5C\x4D\xFD\x2F\x11",
    b"\x4F\xE8\x68\xC9\xA8\xD9\xFE\xD8\x6E\x0C\x21\x75\xA2\xBD\x7E\x89",
    b"\xB9\xC7\xB5\x13\xF4\x1A\x79\x61\x44\x39\x10\xEF\xF9\xD7\xFE\x57",
    b"\x22\x18\xD5\x6D\xFB\x7F\x49\x7A\xA4\xCB\x90\xD4\xF1\xAE\xB1\x76",
    b"\xE4\x68\x5D\xA7\x94\x40\x60\x98\x2F\x04\x48\x40\x1F\xCF\xC6\xBA",
    b"\xEB\xDA\x16\x30\xB4\x73\xB4\x15\x23\x35\x08\x07\x0A\x9F\x4F\x89",
    b"\x78\xE6\x2C\xEC\x5E\x92\x46\xA5\xA8\xBD\xA0\x85\x78\x68\x75\x0C",
    b"\x3A\x11\x2F\xAF\x95\xE8\x38\xC8\x99\x0E\x87\xB1\x62\xCD\x10\xDA",
    b"\xB3\x31\x96\x65\xEF\x88\x9B\x54\x1B\xB3\x36\xBB\x67\x53\x9F\xAF",
    b"\xC2\xAE\x2D\x0A\x2E\x75\xC0\x23\x74\xEA\x4E\xAC\x8D\x99\x50\x7F",
    b"\x59\xB9\x53\x77\x30\x5F\x26\x35\xC6\x08\xA9\x90\x93\xAC\x8F\xC6",
    b"\xDE\x23\xB9\x7A\xEA\x70\xB4\xC4\xCF\x66\xB3\x0E\x58\x32\x0E\xC5",
    b"\xB6\x72\x04\x48\xCE\x3B\xB1\x1C\x53\x1F\xCB\x70\x28\x7C\xB5\xC2",
    b"\x7C\x67\x4F\xBB\xFD\x8C\x7F\xC9\x42\x20\xA4\x73\x23\x1D\x58\x7E",
    b"\x5A\x1A\x1A\x82\xE3\x75\x79\xA1\xBB\x82\x6E\xCE\x01\x71\xC9\x75",
    b"\x63\x47\x4B\x1D\x46\xE6\x79\xB2\x82\x37\x62\x11\xCD\xC7\x00\x2F",
    b"\x46\x87\xC2\x3C\x6D\xC0\xD5\xB5\x78\x6E\xE1\xF2\x73\xFF\x01\x92",
    b"\x50\x0F\xF4\xC7\x50\x6A\xEE\x72\xB6\xF4\x3D\xF6\x08\xFE\xA5\x83",
    b"\xA1\xF9\x86\x0F\x87\xAF\x52\x44\x54\xBB\x47\xC3\x06\x0C\x94\xE9",
    b"\x9B\xF7\xD6\x32\xA7\xC8\xAB\x4B\x4F\xF5\x35\x21\x1F\xC1\x80\x47",
    b"\xBB\x7A\xFA\x5A\x2B\xD7\xB8\x84\xAD\x8E\x56\x4F\x5B\x89\xFF\x37",
    b"\x97\x37\xF1\xF5\x01\x3B\x1F\x9E\xC4\x18\x6F\x92\x2A\xD5\xC4\xB3",
    b"\xC0\xD5\x87\x0B\x9C\x04\xAF\x1A\xB5\xF3\xBC\x6D\x0A\xF1\x7D\x47",
    b"\x08\xE4\x43\xE9\x73\xF7\xB7\x70\x77\x54\xBA\xF3\xEC\xD2\xAC\x49"
)


ROOT_CERT_KEY = (
    b"\xB2\x79\xC9\xE2\xEE\xE1\x21\xC6\xEA\xF4\x4F\xF6\x39\xF8\x8F\x07",
    b"\x8B\x4B\x77\xED\x9F\x95\x60\xB0\x35\x82\x81\xB5\x0E\x55\xAB\x72",
    b"\x11\x15\xA1\x77\x70\x3C\x7A\x30\xFE\x3A\xE9\xEF\x1C\x60\xBC\x1D",
    b"\x97\x46\x76\xB2\x3A\x68\xCC\x04\xB1\x98\x52\x5B\xC9\x68\xF1\x1D",
    b"\xE2\xDB\x50\xE4\xD9\xE7\xF0\x71\xE5\x62\xDA\xE2\x09\x22\x33\xE9",
    b"\xD3\x63\xF6\x1D\xD7\xC1\x9F\xF3\xA4\xA9\x1E\x8F\x65\x53\xD4\x71",
    b"\xDD\x7B\x84\xB9\xF1\xB8\xCE\x73\x35\xF0\xF5\x54\x05\x63\xA1\xEA",
    b"\xB8\x39\x63\xE0\x9B\xE9\x01\x01\x1F\x99\x54\x63\x61\x28\x70\x20",
    b"\xE9\xCC\x0D\xAB\x48\x7F\x14\x0D\x66\x26\xA1\x83\x6D\x27\x11\x1F",
    b"\x20\x68\xDE\x47\x72\x14\x91\x51\xCF\x69\xC6\x1B\xA6\x0E\xF9\xD9",
    b"\x49\xA0\xF7\x1F\x54\x99\xF2\xD3\x9A\xD2\x8C\x70\x05\x34\x82\x93",
    b"\xC4\x31\xFF\xBD\x33\xF6\xBC\xA6\x0D\xC7\x19\x5E\xA2\xBC\xC5\x6D",
    b"\x20\x0B\xAF\x6D\x06\xD0\x9C\x41\xDB\x8D\xE9\xC7\x20\x15\x4C\xA4",
    b"\x83\x2B\x69\xC0\x8C\x69\xCD\x3B\x07\x3A\x00\x63\x60\x2F\x46\x2D",
    b"\x33\x80\x61\xA5\xEA\x6C\x91\x5C\xD5\x62\x35\x79\xC3\xEB\x64\xCE",
    b"\x44\xEF\x58\x6D\x14\xBA\xAA\x88\x34\x01\x9B\x3E\xEB\xEE\xD3\x79"
)


class KeyType(IntEnum):
    RSA4096 = 0
    RSA2048 = 1
    ECCB233 = 2


class CertName(str, Enum):
    IOS_ROOT = "Root"
    CERT_VERIFIER = "CA00000001"
    TICKET_VERIFIER = "XS00000003"
    TMD_VERIFIER = "CP00000004"
    DEVICE_CERT_VERIFIER = "MS00000002"
    DEVICE_AP_CERT_VERIFIER = "NG{:8}"
    SAVEDATA_VERIFIER = "AP{:16}"

    @classmethod
    def _missing_(cls, value):
        for member in cls:
            if member.value.format(value[2:]) == value:
                return member
        return None

@dataclass(init=True, eq=True)
class CertificateData():
    issuer: str
    keyType: KeyType
    keyName: str
    keyID: int
    publicKey: bytes

    def __len__(self) -> int:
        return 0x48


class Certificate(ABC):
    def __init__(
        self,
        signature: Signature,
        data: CertificateData,
    ):
        self.signature = signature
        self.data = data

    @classmethod
    def root(cls) -> "Certificate":
        cert = cls()

    @abstractmethod
    @classmethod
    def from_bytes(cls, data: Union[bytes, BytesIO]) -> "Certificate": ...

    @abstractmethod
    def to_bytes(self) -> bytes: ...

    @abstractmethod
    def size(self) -> int: ...

    def __len__(self) -> int:
        return self.size()


class CertificateRSA4096(Certificate):
    """
    Abstraction of sign verification data on Wii discs
    """

    @classmethod
    def from_bytes(cls, data: Union[bytes, BytesIO]) -> "Certificate": ...

    def to_bytes(self) -> bytes: ...

    def size(self) -> int:
        return len(self.signature) + len(self.header) + 0x138


class CertificateRSA2048(Certificate):
    """
    Abstraction of sign verification data on Wii discs
    """

    @classmethod
    def from_bytes(cls, data: Union[bytes, BytesIO]) -> "Certificate":
        if isinstance(data, bytes):
            data = BytesIO(data)

        # Skip the signature type, it is known here
        data.seek(4, 1)

        sigdata = data.read(0x100)
        issuer = read_string(data, maxlen=0x40)

        # Certificate data
        keyType = KeyType(read_uint32(data))
        keyName = read_string(data, maxlen=0x40)
        keyID = read_uint32(data)
        publicKey = data.read(0x100)
        certheader = CertificateData(
            issuer, keyType, keyName, keyID, publicKey)

        data.seek(0x38, 1)  # Skip padding

        # Signature
        signature = SignatureRSA2048(sigdata, publickey=publicKey, name=issuer)

        # Build the certificate
        cert = cls(signature, certheader)
        return cert

    def to_bytes(self) -> bytes: ...

    def size(self) -> int:
        return len(self.signature) + len(self.header) + 0x138


class CertificateECCB233(Certificate):
    """
    Abstraction of sign verification data on Wii discs
    """

    @classmethod
    def from_bytes(cls, data: Union[bytes, BytesIO]) -> "Certificate": ...

    def to_bytes(self) -> bytes: ...

    def size(self) -> int:
        return len(self.signature) + len(self.header) + 0x78


class CertificateChain(list):
    """
    Accessor object for a chain of certificates
    """

    def __init__(self):
        certData = CertificateData("Root", KeyType.RSA2048, CertName.CERT_VERIFIER, 0x4E005FF1, ROOT_CERT_KEY)
        signature = SignatureRSA4096(ROOT_CERT_SIG, RSA.import_key(certData.publicKey))
        rootCert = CertificateRSA4096(signature, certData)
        self.chain = {"ROOT": rootCert}

    def get_issuer(self, cert: Certificate):

    def __iter__(self): ...


def get_key_length(type: KeyType) -> int:
    if type == KeyType.RSA4096:
        return 0x23C
    if type == KeyType.RSA2048:
        return 0x13C
    if type == KeyType.ECCB233:
        return 0x78
    return -1
